var tipuesearch = {"pages":[{"title":" utf8-f ","text":"utf8-f Prototype of UTF-8 manipulation in Fortran. Example use utf8 implicit none type ( utf8_string ) :: s call construct_utf8_string ( s , \"Fortran さいこう\" ) write ( * , \"('s is a valid utf-8 string: ',g0)\" ) utf8_valid ( s ) write ( * , \"('The number of code points: ',g0)\" ) utf8_len ( s ) write ( * , \"('The 10th code point is ',3A)\" ) \"'\" , utf8_at ( s , 10 ), \"'\" block !! iterate all code points type ( utf8_string_iterator ) :: it it = s % iterator () do while ( it % has_next ()) write ( * , \"(3A)\" ) \"'\" , it % get_next (), \"'\" end do end block Developer Info St Maxwell","tags":"home","loc":"index.html"},{"title":"utf8_string – utf8-f ","text":"type, public :: utf8_string Contents Variables str Type-Bound Procedures iterator Components Type Visibility Attributes Name Initial character(kind=c_char,len=:), public, allocatable :: str Type-Bound Procedures procedure, public :: iterator public function iterator (this) result(itr) return an iterator of utf8_string Arguments Type Intent Optional Attributes Name class( utf8_string ), intent(in), target :: this Return Value type( utf8_string_iterator )","tags":"","loc":"type/utf8_string.html"},{"title":"utf8_string_iterator – utf8-f ","text":"type, public :: utf8_string_iterator Contents Variables cur ptr Type-Bound Procedures get_next has_next Components Type Visibility Attributes Name Initial integer, public :: cur = 1 character(kind=c_char,len=:), public, pointer :: ptr => null() Type-Bound Procedures procedure, public :: get_next => iterator_get_next public function iterator_get_next (this) result(cp) Arguments Type Intent Optional Attributes Name class( utf8_string_iterator ), intent(inout) :: this Return Value character(kind=c_char,len=:),allocatable procedure, public :: has_next => iterator_has_next public pure function iterator_has_next (this) result(r) iterator methods Arguments Type Intent Optional Attributes Name class( utf8_string_iterator ), intent(in) :: this Return Value logical","tags":"","loc":"type/utf8_string_iterator.html"},{"title":"cast_byte – utf8-f","text":"public pure function cast_byte(char) result(byte) private helper functions\ncast char to byte (8-bits integer in Fortran)\ndisplay: private Arguments Type Intent Optional Attributes Name character(kind=c_char,len=1), intent(in) :: char Return Value integer(kind=c_int8_t) Contents Source Code cast_byte Source Code pure function cast_byte ( char ) result ( byte ) character ( kind = c_char , len = 1 ), intent ( in ) :: char integer ( kind = c_int8_t ) :: byte byte = transfer ( char , byte ) end function cast_byte","tags":"","loc":"proc/cast_byte.html"},{"title":"codepoint_num_bytes – utf8-f","text":"public pure function codepoint_num_bytes(byte) result(n) get the number of bytes of a code point based on its first byte\ndisplay: private Arguments Type Intent Optional Attributes Name integer(kind=c_int8_t), intent(in) :: byte Return Value integer Contents Source Code codepoint_num_bytes Source Code pure function codepoint_num_bytes ( byte ) result ( n ) integer ( kind = c_int8_t ), intent ( in ) :: byte integer :: n n = NUM_BYTES_UTF8 ( iand ( int ( byte , 4 ), int ( z '000000FF' , 4 ))) if ( n == 0 ) n = 1 end function codepoint_num_bytes","tags":"","loc":"proc/codepoint_num_bytes.html"},{"title":"iterator – utf8-f","text":"public function iterator(this) result(itr) return an iterator of utf8_string Arguments Type Intent Optional Attributes Name class( utf8_string ), intent(in), target :: this Return Value type( utf8_string_iterator ) Contents Source Code iterator Source Code function iterator ( this ) result ( itr ) class ( utf8_string ), target , intent ( in ) :: this type ( utf8_string_iterator ) :: itr itr % ptr => this % str end function iterator","tags":"","loc":"proc/iterator.html"},{"title":"iterator_get_next – utf8-f","text":"public function iterator_get_next(this) result(cp) Arguments Type Intent Optional Attributes Name class( utf8_string_iterator ), intent(inout) :: this Return Value character(kind=c_char,len=:),allocatable Contents Source Code iterator_get_next Source Code function iterator_get_next ( this ) result ( cp ) class ( utf8_string_iterator ), intent ( inout ) :: this !character(len=:, kind=c_char), pointer :: cp character ( len = :, kind = c_char ), allocatable :: cp integer :: n n = codepoint_num_bytes ( cast_byte ( this % ptr ( this % cur : this % cur ))) cp = this % ptr ( this % cur : this % cur + n - 1 ) this % cur = this % cur + n end function iterator_get_next","tags":"","loc":"proc/iterator_get_next.html"},{"title":"iterator_has_next – utf8-f","text":"public pure function iterator_has_next(this) result(r) iterator methods Arguments Type Intent Optional Attributes Name class( utf8_string_iterator ), intent(in) :: this Return Value logical Contents Source Code iterator_has_next Source Code pure function iterator_has_next ( this ) result ( r ) class ( utf8_string_iterator ), intent ( in ) :: this logical :: r r = this % cur <= len ( this % ptr ) end function iterator_has_next","tags":"","loc":"proc/iterator_has_next.html"},{"title":"utf8_at – utf8-f","text":"public pure function utf8_at(utf8, idx) result(s) return the code point at specified position Arguments Type Intent Optional Attributes Name class( utf8_string ), intent(in) :: utf8 integer, intent(in) :: idx Return Value character(kind=c_char,len=:),allocatable Contents Source Code utf8_at Source Code pure function utf8_at ( utf8 , idx ) result ( s ) class ( utf8_string ), intent ( in ) :: utf8 integer , intent ( in ) :: idx character ( len = :, kind = c_char ), allocatable :: s integer :: i , j , n if ( idx < 1 ) then allocate ( character ( len = 0 , kind = c_char ) :: s ); return end if i = 1 ; j = 1 do if ( i > len ( utf8 % str )) then allocate ( character ( len = 0 , kind = c_char ) :: s ); return end if n = codepoint_num_bytes ( cast_byte ( utf8 % str ( i : i ))) if ( j == idx ) then allocate ( s , source = utf8 % str ( i : i + n - 1 )); return end if i = i + n j = j + 1 end do end function utf8_at","tags":"","loc":"proc/utf8_at.html"},{"title":"utf8_count – utf8-f","text":"public pure function utf8_count(utf8, substring) result(count) count the substring in utf8_string\noverlaps are not considered\ne.g. utf8_count(“AUAUAUAUAUAUAU”,”AUA”) returns 3 Arguments Type Intent Optional Attributes Name class( utf8_string ), intent(in) :: utf8 character(kind=c_char,len=*), intent(in) :: substring Return Value integer Contents Source Code utf8_count Source Code pure function utf8_count ( utf8 , substring ) result ( count ) class ( utf8_string ), intent ( in ) :: utf8 character ( len =* , kind = c_char ), intent ( in ) :: substring integer :: count if (. not . utf8_is_valid ( substring ) . or . len ( substring ) == 0 ) then count = 0 ; return end if count = count_internal ( utf8 % str , substring ) contains pure recursive function count_internal ( full , sub ) result ( c ) character ( len =* , kind = c_char ), intent ( in ) :: full character ( len =* , kind = c_char ), intent ( in ) :: sub integer :: c integer :: l , idx l = len ( sub ) idx = index ( full , sub ) if ( idx == 0 ) then c = 0 ; return else c = count_internal ( full ( idx + l :), sub ) + 1 end if end function count_internal end function utf8_count","tags":"","loc":"proc/utf8_count.html"},{"title":"utf8_index – utf8-f","text":"public pure function utf8_index(utf8, substring) result(idx) return the position where substring occurs in utf8_string for the first time Arguments Type Intent Optional Attributes Name class( utf8_string ), intent(in) :: utf8 character(kind=c_char,len=*), intent(in) :: substring Return Value integer Contents Source Code utf8_index Source Code pure function utf8_index ( utf8 , substring ) result ( idx ) class ( utf8_string ), intent ( in ) :: utf8 character ( len =* , kind = c_char ), intent ( in ) :: substring integer :: idx integer :: bit , cit integer :: nt , ls idx = 0 bit = 1 ; cit = 1 ls = len ( substring ) do if ( bit + ls - 1 > len ( utf8 % str )) exit if ( utf8 % str ( bit : bit + ls - 1 ) == substring (:)) then idx = cit ; return end if nt = codepoint_num_bytes ( cast_byte ( utf8 % str ( bit : bit ))) bit = bit + nt cit = cit + 1 end do end function utf8_index","tags":"","loc":"proc/utf8_index.html"},{"title":"utf8_is_valid_char – utf8-f","text":"public pure function utf8_is_valid_char(str) result(r) check if the whole string is valid utf8 encoding Arguments Type Intent Optional Attributes Name character(kind=c_char,len=*), intent(in) :: str Return Value logical Contents Source Code utf8_is_valid_char Source Code pure function utf8_is_valid_char ( str ) result ( r ) character ( len =* , kind = c_char ), intent ( in ) :: str logical :: r integer ( kind = c_int8_t ) :: byte integer :: i , n i = 1 do if ( i > len ( str )) exit byte = cast_byte ( str ( i : i )) if ( iand ( byte , int ( z '80' , c_int8_t )) == int ( z '00' , c_int8_t )) then ! first byte: 0xxxxxxx and 00..7F i = i + 1 else if ( iand ( byte , int ( z 'E0' , c_int8_t )) == int ( z 'C0' , c_int8_t ) . and . & iand ( byte , int ( z '1F' , c_int8_t )) > int ( z '01' , c_int8_t )) then ! first byte: 110yyyyy and C2..DF if ( i + 1 > len ( str )) then r = . false .; return end if byte = cast_byte ( str ( i + 1 : i + 1 )) if ( iand ( byte , int ( z 'C0' , c_int8_t )) /= int ( z '80' , c_int8_t )) then ! secpnd byte: 10xxxxxx and 80..BF r = . false .; return end if i = i + 2 else if ( iand ( byte , int ( z 'F0' , c_int8_t )) == int ( z 'E0' , c_int8_t )) then ! first byte: 1110zzzz and E0..EF if ( i + 2 > len ( str )) then r = . false .; return end if if ( iand ( cast_byte ( str ( i + 1 : i + 1 )), int ( z 'C0' , c_int8_t )) /= int ( z '80' , c_int8_t ) . or . & iand ( cast_byte ( str ( i + 2 : i + 2 )), int ( z 'C0' , c_int8_t )) /= int ( z '80' , c_int8_t )) then ! second and third bytes: 10xxxxxx r = . false .; return end if if ( byte == int ( z 'E0' , c_int8_t )) then if ( iand ( cast_byte ( str ( i + 1 : i + 1 )), int ( z '3F' , c_int8_t )) < int ( z '20' , c_int8_t )) then ! E0  A0..BF  80..BF r = . false .; return end if end if if ( byte == int ( z 'ED' , c_int8_t )) then if ( iand ( cast_byte ( str ( i + 1 : i + 1 )), int ( z '3F' , c_int8_t )) > int ( z '1F' , c_int8_t )) then ! ED  80..9F  80..BF r = . false .; return end if end if i = i + 3 else if ( iand ( byte , int ( z 'F8' , c_int8_t )) == int ( z 'F0' , c_int8_t ) . and . & iand ( byte , int ( z '07' , c_int8_t )) < int ( z '05' , c_int8_t )) then ! first byte: 11110uuu and F0..F4 if ( i + 3 > len ( str )) then r = . false .; return end if if ( iand ( cast_byte ( str ( i + 1 : i + 1 )), int ( z 'C0' , c_int8_t )) /= int ( z '80' , c_int8_t ) . or . & iand ( cast_byte ( str ( i + 2 : i + 2 )), int ( z 'C0' , c_int8_t )) /= int ( z '80' , c_int8_t ) . or . & iand ( cast_byte ( str ( i + 3 : i + 3 )), int ( z 'C0' , c_int8_t )) /= int ( z '80' , c_int8_t )) then ! second, third, and last bytes: 10xxxxxx r = . false .; return end if if ( byte == int ( z 'F0' , c_int8_t )) then if ( iand ( cast_byte ( str ( i + 1 : i + 1 )), int ( z '3F' , c_int8_t )) < int ( z '10' , c_int8_t )) then ! F0  90..BF  80..BF  80..BF r = . false .; return end if end if if ( byte == int ( z 'F4' , c_int8_t )) then if ( iand ( cast_byte ( str ( i + 1 : i + 1 )), int ( z '3F' , c_int8_t )) > int ( z '0F' , c_int8_t )) then ! F4  80..8F  80..BF  80..BF r = . false .; return end if end if i = i + 4 else r = . false .; return end if end do r = . true . end function utf8_is_valid_char","tags":"","loc":"proc/utf8_is_valid_char.html"},{"title":"utf8_is_valid_string – utf8-f","text":"public pure function utf8_is_valid_string(str) result(r) Arguments Type Intent Optional Attributes Name type( utf8_string ), intent(in) :: str Return Value logical Contents Source Code utf8_is_valid_string Source Code pure function utf8_is_valid_string ( str ) result ( r ) type ( utf8_string ), intent ( in ) :: str logical :: r r = utf8_is_valid_char ( str % str ) end function utf8_is_valid_string","tags":"","loc":"proc/utf8_is_valid_string.html"},{"title":"utf8_len – utf8-f","text":"public pure function utf8_len(utf8) result(l) return the number of UTF-8 code points Arguments Type Intent Optional Attributes Name class( utf8_string ), intent(in) :: utf8 Return Value integer Contents Source Code utf8_len Source Code pure function utf8_len ( utf8 ) result ( l ) class ( utf8_string ), intent ( in ) :: utf8 integer :: l integer :: i l = 0 ; i = 1 do if ( i > len ( utf8 % str )) exit i = i + codepoint_num_bytes ( cast_byte ( utf8 % str ( i : i ))) l = l + 1 end do end function utf8_len","tags":"","loc":"proc/utf8_len.html"},{"title":"utf8_slice – utf8-f","text":"public pure function utf8_slice(utf8, begin, end) result(slice) return a substring of utf8_string Arguments Type Intent Optional Attributes Name class( utf8_string ), intent(in) :: utf8 integer, intent(in) :: begin integer, intent(in) :: end Return Value character(kind=c_char,len=:),allocatable Contents Source Code utf8_slice Source Code pure function utf8_slice ( utf8 , begin , end ) result ( slice ) class ( utf8_string ), intent ( in ) :: utf8 integer , intent ( in ) :: begin integer , intent ( in ) :: end character ( len = :, kind = c_char ), allocatable :: slice integer :: bi , bj ! byte index for begin (i) and end (j) integer :: ci , cj ! codepoint index for begin (i) and end (j) integer :: n if ( begin > end . or . begin > len ( utf8 % str ) . or . end < 1 ) then allocate ( character ( len = 0 , kind = c_char ) :: slice ); return end if bi = 1 ; ci = 1 if ( begin > 1 ) then do if ( ci == begin ) exit if ( bi > len ( utf8 % str )) then allocate ( character ( len = 0 , kind = c_char ) :: slice ); return end if n = codepoint_num_bytes ( cast_byte ( utf8 % str ( bi : bi ))) bi = bi + n ci = ci + 1 end do end if bj = bi ; cj = ci do if ( bj > len ( utf8 % str )) then allocate ( slice , source = utf8 % str ( bi :)); return end if n = codepoint_num_bytes ( cast_byte ( utf8 % str ( bi : bi ))) if ( cj == end ) then allocate ( slice , source = utf8 % str ( bi : bj + n - 1 )); return end if bj = bj + n cj = cj + 1 end do end function utf8_slice","tags":"","loc":"proc/utf8_slice.html"},{"title":"char_assign_from_utf8 – utf8-f","text":"public subroutine char_assign_from_utf8(str, utf8) Arguments Type Intent Optional Attributes Name character(kind=c_char,len=:), intent(out), allocatable :: str type( utf8_string ), intent(in) :: utf8 Contents Source Code char_assign_from_utf8 Source Code subroutine char_assign_from_utf8 ( str , utf8 ) character ( len = :, kind = c_char ), allocatable , intent ( out ) :: str type ( utf8_string ), intent ( in ) :: utf8 if ( allocated ( utf8 % str )) then allocate ( str , source = utf8 % str ) else allocate ( character ( len = 0 , kind = c_char ) :: str ) end if end subroutine char_assign_from_utf8","tags":"","loc":"proc/char_assign_from_utf8.html"},{"title":"utf8_assign_from_char – utf8-f","text":"public subroutine utf8_assign_from_char(utf8, str) Arguments Type Intent Optional Attributes Name type( utf8_string ), intent(out) :: utf8 character(kind=c_char,len=*), intent(in) :: str Contents Source Code utf8_assign_from_char Source Code subroutine utf8_assign_from_char ( utf8 , str ) type ( utf8_string ), intent ( out ) :: utf8 character ( len =* , kind = c_char ), intent ( in ) :: str call utf8_construct_from_char ( utf8 , str , . false .) end subroutine utf8_assign_from_char","tags":"","loc":"proc/utf8_assign_from_char.html"},{"title":"utf8_construct_from_char – utf8-f","text":"public subroutine utf8_construct_from_char(utf8, str, escape) Arguments Type Intent Optional Attributes Name type( utf8_string ), intent(out) :: utf8 character(kind=c_char,len=*), intent(in) :: str logical, intent(in), optional :: escape Contents Source Code utf8_construct_from_char Source Code subroutine utf8_construct_from_char ( utf8 , str , escape ) type ( utf8_string ), intent ( out ) :: utf8 character ( len =* , kind = c_char ), intent ( in ) :: str logical , optional , intent ( in ) :: escape !! if parse unicode escape sequence \\uXXXX, default is .false. logical :: parse if ( present ( escape )) then parse = escape else parse = . false . end if if ( parse ) then ! to be implemented allocate ( utf8 % str , source = str ) else allocate ( utf8 % str , source = str ) end if end subroutine utf8_construct_from_char","tags":"","loc":"proc/utf8_construct_from_char.html"},{"title":"utf8_reverse – utf8-f","text":"public subroutine utf8_reverse(utf8) reverse the order of code points in place Arguments Type Intent Optional Attributes Name class( utf8_string ), intent(inout) :: utf8 Contents Source Code utf8_reverse Source Code subroutine utf8_reverse ( utf8 ) class ( utf8_string ), intent ( inout ) :: utf8 character ( len = :, kind = c_char ), allocatable :: tmp integer :: i , j , l , n l = len ( utf8 % str ) call move_alloc ( from = utf8 % str , to = tmp ) allocate ( character ( len = l , kind = c_char ) :: utf8 % str ) i = 1 ; j = l do if ( i > l ) exit n = codepoint_num_bytes ( cast_byte ( tmp ( i : i ))) utf8 % str ( j - n + 1 : j ) = tmp ( i : i + n - 1 ) i = i + n j = j - n end do end subroutine utf8_reverse","tags":"","loc":"proc/utf8_reverse.html"},{"title":"utf8_split – utf8-f","text":"public subroutine utf8_split(utf8, sep, list) split utf8_string based on the separation string Arguments Type Intent Optional Attributes Name class( utf8_string ), intent(in), target :: utf8 character(kind=c_char,len=*), intent(in) :: sep type( utf8_string ), intent(out), dimension(:), allocatable :: list Contents Source Code utf8_split Source Code subroutine utf8_split ( utf8 , sep , list ) class ( utf8_string ), intent ( in ), target :: utf8 character ( len =* , kind = c_char ), intent ( in ) :: sep type ( utf8_string ), dimension (:), allocatable , intent ( out ) :: list character ( len = :, kind = c_char ), pointer :: ptr integer :: nsep , l integer :: i , e nsep = utf8_count ( utf8 , sep ) allocate ( list ( nsep + 1 )) if ( nsep == 0 ) then allocate ( list ( 1 )% str , source = utf8 % str ) else l = len ( sep ) e = 1 ptr => utf8 % str (:) do i = 1 , nsep e = index ( ptr , sep ) allocate ( list ( i )% str , source = ptr (: e - 1 )) ptr => ptr ( e + l :) end do allocate ( list ( nsep + 1 )% str , source = ptr (:)) end if end subroutine utf8_split","tags":"","loc":"proc/utf8_split.html"},{"title":"assignment(=) – utf8-f","text":"public interface assignment(=) Contents Module Procedures utf8_assign_from_char char_assign_from_utf8 Module Procedures public subroutine utf8_assign_from_char (utf8, str) Arguments Type Intent Optional Attributes Name type( utf8_string ), intent(out) :: utf8 character(kind=c_char,len=*), intent(in) :: str public subroutine char_assign_from_utf8 (str, utf8) Arguments Type Intent Optional Attributes Name character(kind=c_char,len=:), intent(out), allocatable :: str type( utf8_string ), intent(in) :: utf8","tags":"","loc":"interface/assignment(=).html"},{"title":"construct_utf8_string – utf8-f","text":"public interface construct_utf8_string Contents Module Procedures utf8_construct_from_char Module Procedures public subroutine utf8_construct_from_char (utf8, str, escape) Arguments Type Intent Optional Attributes Name type( utf8_string ), intent(out) :: utf8 character(kind=c_char,len=*), intent(in) :: str logical, intent(in), optional :: escape","tags":"","loc":"interface/construct_utf8_string.html"},{"title":"utf8_is_valid – utf8-f","text":"public interface utf8_is_valid Contents Module Procedures utf8_is_valid_char utf8_is_valid_string Module Procedures public pure function utf8_is_valid_char (str) result(r) check if the whole string is valid utf8 encoding Arguments Type Intent Optional Attributes Name character(kind=c_char,len=*), intent(in) :: str Return Value logical public pure function utf8_is_valid_string (str) result(r) Arguments Type Intent Optional Attributes Name type( utf8_string ), intent(in) :: str Return Value logical","tags":"","loc":"interface/utf8_is_valid.html"},{"title":"utf8_const – utf8-f","text":"Uses iso_c_binding Contents Variables NUM_BYTES_UTF8 utf8_invalid_byte utf8_invalid_unicode_hex utf8_invalid_unicode_surrogate utf8_ok Variables Type Visibility Attributes Name Initial integer, public, parameter, dimension(0:255) :: NUM_BYTES_UTF8 = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] refer to Table 3-7. Well-Formed UTF-8 Byte Sequences\nin http://www.unicode.org/versions/Unicode10.0.0/UnicodeStandard-10.0.pdf\ndisplay: private integer, public, parameter :: utf8_invalid_byte = 1 integer, public, parameter :: utf8_invalid_unicode_hex = 2 integer, public, parameter :: utf8_invalid_unicode_surrogate = 3 integer, public, parameter :: utf8_ok = 0","tags":"","loc":"module/utf8_const.html"},{"title":"utf8 – utf8-f","text":"Uses utf8_detail Contents None","tags":"","loc":"module/utf8.html"},{"title":"utf8_detail – utf8-f","text":"Uses utf8_const Contents Interfaces assignment(=) construct_utf8_string utf8_is_valid Derived Types utf8_string utf8_string_iterator Functions cast_byte codepoint_num_bytes iterator iterator_get_next iterator_has_next utf8_at utf8_count utf8_index utf8_is_valid_char utf8_is_valid_string utf8_len utf8_slice Subroutines char_assign_from_utf8 utf8_assign_from_char utf8_construct_from_char utf8_reverse utf8_split Interfaces public interface assignment(=) public subroutine utf8_assign_from_char (utf8, str) Arguments Type Intent Optional Attributes Name type( utf8_string ), intent(out) :: utf8 character(kind=c_char,len=*), intent(in) :: str public subroutine char_assign_from_utf8 (str, utf8) Arguments Type Intent Optional Attributes Name character(kind=c_char,len=:), intent(out), allocatable :: str type( utf8_string ), intent(in) :: utf8 public interface construct_utf8_string public subroutine utf8_construct_from_char (utf8, str, escape) Arguments Type Intent Optional Attributes Name type( utf8_string ), intent(out) :: utf8 character(kind=c_char,len=*), intent(in) :: str logical, intent(in), optional :: escape public interface utf8_is_valid public pure function utf8_is_valid_char (str) result(r) check if the whole string is valid utf8 encoding Arguments Type Intent Optional Attributes Name character(kind=c_char,len=*), intent(in) :: str Return Value logical public pure function utf8_is_valid_string (str) result(r) Arguments Type Intent Optional Attributes Name type( utf8_string ), intent(in) :: str Return Value logical Derived Types type, public :: utf8_string Components Type Visibility Attributes Name Initial character(kind=c_char,len=:), public, allocatable :: str Type-Bound Procedures procedure, public :: iterator type, public :: utf8_string_iterator Components Type Visibility Attributes Name Initial integer, public :: cur = 1 character(kind=c_char,len=:), public, pointer :: ptr => null() Type-Bound Procedures procedure, public :: get_next => iterator_get_next procedure, public :: has_next => iterator_has_next Functions public pure function cast_byte (char) result(byte) private helper functions\ncast char to byte (8-bits integer in Fortran)\ndisplay: private Arguments Type Intent Optional Attributes Name character(kind=c_char,len=1), intent(in) :: char Return Value integer(kind=c_int8_t) public pure function codepoint_num_bytes (byte) result(n) get the number of bytes of a code point based on its first byte\ndisplay: private Arguments Type Intent Optional Attributes Name integer(kind=c_int8_t), intent(in) :: byte Return Value integer public function iterator (this) result(itr) return an iterator of utf8_string Arguments Type Intent Optional Attributes Name class( utf8_string ), intent(in), target :: this Return Value type( utf8_string_iterator ) public function iterator_get_next (this) result(cp) Arguments Type Intent Optional Attributes Name class( utf8_string_iterator ), intent(inout) :: this Return Value character(kind=c_char,len=:),allocatable public pure function iterator_has_next (this) result(r) iterator methods Arguments Type Intent Optional Attributes Name class( utf8_string_iterator ), intent(in) :: this Return Value logical public pure function utf8_at (utf8, idx) result(s) return the code point at specified position Arguments Type Intent Optional Attributes Name class( utf8_string ), intent(in) :: utf8 integer, intent(in) :: idx Return Value character(kind=c_char,len=:),allocatable public pure function utf8_count (utf8, substring) result(count) count the substring in utf8_string\noverlaps are not considered\ne.g. utf8_count(“AUAUAUAUAUAUAU”,”AUA”) returns 3 Arguments Type Intent Optional Attributes Name class( utf8_string ), intent(in) :: utf8 character(kind=c_char,len=*), intent(in) :: substring Return Value integer public pure function utf8_index (utf8, substring) result(idx) return the position where substring occurs in utf8_string for the first time Arguments Type Intent Optional Attributes Name class( utf8_string ), intent(in) :: utf8 character(kind=c_char,len=*), intent(in) :: substring Return Value integer public pure function utf8_is_valid_char (str) result(r) check if the whole string is valid utf8 encoding Arguments Type Intent Optional Attributes Name character(kind=c_char,len=*), intent(in) :: str Return Value logical public pure function utf8_is_valid_string (str) result(r) Arguments Type Intent Optional Attributes Name type( utf8_string ), intent(in) :: str Return Value logical public pure function utf8_len (utf8) result(l) return the number of UTF-8 code points Arguments Type Intent Optional Attributes Name class( utf8_string ), intent(in) :: utf8 Return Value integer public pure function utf8_slice (utf8, begin, end) result(slice) return a substring of utf8_string Arguments Type Intent Optional Attributes Name class( utf8_string ), intent(in) :: utf8 integer, intent(in) :: begin integer, intent(in) :: end Return Value character(kind=c_char,len=:),allocatable Subroutines public subroutine char_assign_from_utf8 (str, utf8) Arguments Type Intent Optional Attributes Name character(kind=c_char,len=:), intent(out), allocatable :: str type( utf8_string ), intent(in) :: utf8 public subroutine utf8_assign_from_char (utf8, str) Arguments Type Intent Optional Attributes Name type( utf8_string ), intent(out) :: utf8 character(kind=c_char,len=*), intent(in) :: str public subroutine utf8_construct_from_char (utf8, str, escape) Arguments Type Intent Optional Attributes Name type( utf8_string ), intent(out) :: utf8 character(kind=c_char,len=*), intent(in) :: str logical, intent(in), optional :: escape public subroutine utf8_reverse (utf8) reverse the order of code points in place Arguments Type Intent Optional Attributes Name class( utf8_string ), intent(inout) :: utf8 public subroutine utf8_split (utf8, sep, list) split utf8_string based on the separation string Arguments Type Intent Optional Attributes Name class( utf8_string ), intent(in), target :: utf8 character(kind=c_char,len=*), intent(in) :: sep type( utf8_string ), intent(out), dimension(:), allocatable :: list","tags":"","loc":"module/utf8_detail.html"},{"title":"utf8-f_const.f90 – utf8-f","text":"Contents Modules utf8_const Source Code utf8-f_const.f90 Source Code module utf8_const use iso_c_binding , only : c_char , c_int8_t , c_int32_t implicit none public integer , parameter :: utf8_ok = 0 integer , parameter :: utf8_invalid_byte = 1 integer , parameter :: utf8_invalid_unicode_hex = 2 integer , parameter :: utf8_invalid_unicode_surrogate = 3 !> refer to Table 3-7. Well-Formed UTF-8 Byte Sequences !> in http://www.unicode.org/versions/Unicode10.0.0/UnicodeStandard-10.0.pdf !> display: private integer , dimension ( 0 : 255 ), parameter :: NUM_BYTES_UTF8 = [ & 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , & ! 0x00..0x0F 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , & ! 0x10..0x1F 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , & ! 0x20..0x2F 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , & ! 0x30..0x3F 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , & ! 0x40..0x4F 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , & ! 0x50..0x5F 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , & ! 0x60..0x6F 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , & ! 0x70..0x7F 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , & ! 0x80..0x8F 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , & ! 0x90..0x9F 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , & ! 0xA0..0xAF 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , & ! 0xB0..0xBF 0 , 0 , & ! 0xC0..0xC1 - disallowed in UTF-8 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , & ! 0xC2..0xCF 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , & ! 0xD0..0xDF 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , & ! 0xE0..0xEF 4 , 4 , 4 , 4 , 4 , & ! 0xF0..0xF4 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 & ! 0xF5..0xFF - disallowed in UTF-8 ] end module utf8_const","tags":"","loc":"sourcefile/utf8-f_const.f90.html"},{"title":"utf8-f.f90 – utf8-f","text":"Contents Modules utf8 Source Code utf8-f.f90 Source Code module utf8 use utf8_detail implicit none private public :: utf8_string public :: utf8_string_iterator public :: construct_utf8_string public :: assignment ( = ) public :: utf8_len public :: utf8_at public :: utf8_slice public :: utf8_index public :: utf8_count public :: utf8_split public :: utf8_reverse public :: utf8_is_valid end module utf8","tags":"","loc":"sourcefile/utf8-f.f90.html"},{"title":"utf8-f_detail.f90 – utf8-f","text":"Contents Modules utf8_detail Source Code utf8-f_detail.f90 Source Code module utf8_detail use utf8_const implicit none public type :: utf8_string private character ( len = :, kind = c_char ), allocatable :: str contains procedure :: iterator end type type :: utf8_string_iterator private character ( len = :, kind = c_char ), pointer :: ptr => null () integer :: cur = 1 contains procedure :: has_next => iterator_has_next procedure :: get_next => iterator_get_next end type interface construct_utf8_string module procedure :: utf8_construct_from_char end interface interface assignment ( = ) module procedure :: utf8_assign_from_char module procedure :: char_assign_from_utf8 end interface interface utf8_is_valid module procedure :: utf8_is_valid_char module procedure :: utf8_is_valid_string end interface contains subroutine utf8_construct_from_char ( utf8 , str , escape ) type ( utf8_string ), intent ( out ) :: utf8 character ( len =* , kind = c_char ), intent ( in ) :: str logical , optional , intent ( in ) :: escape !! if parse unicode escape sequence \\uXXXX, default is .false. logical :: parse if ( present ( escape )) then parse = escape else parse = . false . end if if ( parse ) then ! to be implemented allocate ( utf8 % str , source = str ) else allocate ( utf8 % str , source = str ) end if end subroutine utf8_construct_from_char subroutine utf8_assign_from_char ( utf8 , str ) type ( utf8_string ), intent ( out ) :: utf8 character ( len =* , kind = c_char ), intent ( in ) :: str call utf8_construct_from_char ( utf8 , str , . false .) end subroutine utf8_assign_from_char subroutine char_assign_from_utf8 ( str , utf8 ) character ( len = :, kind = c_char ), allocatable , intent ( out ) :: str type ( utf8_string ), intent ( in ) :: utf8 if ( allocated ( utf8 % str )) then allocate ( str , source = utf8 % str ) else allocate ( character ( len = 0 , kind = c_char ) :: str ) end if end subroutine char_assign_from_utf8 !> return the number of UTF-8 code points pure function utf8_len ( utf8 ) result ( l ) class ( utf8_string ), intent ( in ) :: utf8 integer :: l integer :: i l = 0 ; i = 1 do if ( i > len ( utf8 % str )) exit i = i + codepoint_num_bytes ( cast_byte ( utf8 % str ( i : i ))) l = l + 1 end do end function utf8_len !> return the code point at specified position pure function utf8_at ( utf8 , idx ) result ( s ) class ( utf8_string ), intent ( in ) :: utf8 integer , intent ( in ) :: idx character ( len = :, kind = c_char ), allocatable :: s integer :: i , j , n if ( idx < 1 ) then allocate ( character ( len = 0 , kind = c_char ) :: s ); return end if i = 1 ; j = 1 do if ( i > len ( utf8 % str )) then allocate ( character ( len = 0 , kind = c_char ) :: s ); return end if n = codepoint_num_bytes ( cast_byte ( utf8 % str ( i : i ))) if ( j == idx ) then allocate ( s , source = utf8 % str ( i : i + n - 1 )); return end if i = i + n j = j + 1 end do end function utf8_at !> return a substring of utf8_string pure function utf8_slice ( utf8 , begin , end ) result ( slice ) class ( utf8_string ), intent ( in ) :: utf8 integer , intent ( in ) :: begin integer , intent ( in ) :: end character ( len = :, kind = c_char ), allocatable :: slice integer :: bi , bj ! byte index for begin (i) and end (j) integer :: ci , cj ! codepoint index for begin (i) and end (j) integer :: n if ( begin > end . or . begin > len ( utf8 % str ) . or . end < 1 ) then allocate ( character ( len = 0 , kind = c_char ) :: slice ); return end if bi = 1 ; ci = 1 if ( begin > 1 ) then do if ( ci == begin ) exit if ( bi > len ( utf8 % str )) then allocate ( character ( len = 0 , kind = c_char ) :: slice ); return end if n = codepoint_num_bytes ( cast_byte ( utf8 % str ( bi : bi ))) bi = bi + n ci = ci + 1 end do end if bj = bi ; cj = ci do if ( bj > len ( utf8 % str )) then allocate ( slice , source = utf8 % str ( bi :)); return end if n = codepoint_num_bytes ( cast_byte ( utf8 % str ( bi : bi ))) if ( cj == end ) then allocate ( slice , source = utf8 % str ( bi : bj + n - 1 )); return end if bj = bj + n cj = cj + 1 end do end function utf8_slice !> return the position where substring occurs in utf8_string for the first time pure function utf8_index ( utf8 , substring ) result ( idx ) class ( utf8_string ), intent ( in ) :: utf8 character ( len =* , kind = c_char ), intent ( in ) :: substring integer :: idx integer :: bit , cit integer :: nt , ls idx = 0 bit = 1 ; cit = 1 ls = len ( substring ) do if ( bit + ls - 1 > len ( utf8 % str )) exit if ( utf8 % str ( bit : bit + ls - 1 ) == substring (:)) then idx = cit ; return end if nt = codepoint_num_bytes ( cast_byte ( utf8 % str ( bit : bit ))) bit = bit + nt cit = cit + 1 end do end function utf8_index !> count the substring in utf8_string !> overlaps are not considered !> e.g. utf8_count(\"AUAUAUAUAUAUAU\",\"AUA\") returns 3 pure function utf8_count ( utf8 , substring ) result ( count ) class ( utf8_string ), intent ( in ) :: utf8 character ( len =* , kind = c_char ), intent ( in ) :: substring integer :: count if (. not . utf8_is_valid ( substring ) . or . len ( substring ) == 0 ) then count = 0 ; return end if count = count_internal ( utf8 % str , substring ) contains pure recursive function count_internal ( full , sub ) result ( c ) character ( len =* , kind = c_char ), intent ( in ) :: full character ( len =* , kind = c_char ), intent ( in ) :: sub integer :: c integer :: l , idx l = len ( sub ) idx = index ( full , sub ) if ( idx == 0 ) then c = 0 ; return else c = count_internal ( full ( idx + l :), sub ) + 1 end if end function count_internal end function utf8_count !> split utf8_string based on the separation string subroutine utf8_split ( utf8 , sep , list ) class ( utf8_string ), intent ( in ), target :: utf8 character ( len =* , kind = c_char ), intent ( in ) :: sep type ( utf8_string ), dimension (:), allocatable , intent ( out ) :: list character ( len = :, kind = c_char ), pointer :: ptr integer :: nsep , l integer :: i , e nsep = utf8_count ( utf8 , sep ) allocate ( list ( nsep + 1 )) if ( nsep == 0 ) then allocate ( list ( 1 )% str , source = utf8 % str ) else l = len ( sep ) e = 1 ptr => utf8 % str (:) do i = 1 , nsep e = index ( ptr , sep ) allocate ( list ( i )% str , source = ptr (: e - 1 )) ptr => ptr ( e + l :) end do allocate ( list ( nsep + 1 )% str , source = ptr (:)) end if end subroutine utf8_split !> reverse the order of code points in place subroutine utf8_reverse ( utf8 ) class ( utf8_string ), intent ( inout ) :: utf8 character ( len = :, kind = c_char ), allocatable :: tmp integer :: i , j , l , n l = len ( utf8 % str ) call move_alloc ( from = utf8 % str , to = tmp ) allocate ( character ( len = l , kind = c_char ) :: utf8 % str ) i = 1 ; j = l do if ( i > l ) exit n = codepoint_num_bytes ( cast_byte ( tmp ( i : i ))) utf8 % str ( j - n + 1 : j ) = tmp ( i : i + n - 1 ) i = i + n j = j - n end do end subroutine utf8_reverse !> return an iterator of utf8_string function iterator ( this ) result ( itr ) class ( utf8_string ), target , intent ( in ) :: this type ( utf8_string_iterator ) :: itr itr % ptr => this % str end function iterator !> iterator methods pure function iterator_has_next ( this ) result ( r ) class ( utf8_string_iterator ), intent ( in ) :: this logical :: r r = this % cur <= len ( this % ptr ) end function iterator_has_next function iterator_get_next ( this ) result ( cp ) class ( utf8_string_iterator ), intent ( inout ) :: this !character(len=:, kind=c_char), pointer :: cp character ( len = :, kind = c_char ), allocatable :: cp integer :: n n = codepoint_num_bytes ( cast_byte ( this % ptr ( this % cur : this % cur ))) cp = this % ptr ( this % cur : this % cur + n - 1 ) this % cur = this % cur + n end function iterator_get_next !> check if the whole string is valid utf8 encoding pure function utf8_is_valid_char ( str ) result ( r ) character ( len =* , kind = c_char ), intent ( in ) :: str logical :: r integer ( kind = c_int8_t ) :: byte integer :: i , n i = 1 do if ( i > len ( str )) exit byte = cast_byte ( str ( i : i )) if ( iand ( byte , int ( z '80' , c_int8_t )) == int ( z '00' , c_int8_t )) then ! first byte: 0xxxxxxx and 00..7F i = i + 1 else if ( iand ( byte , int ( z 'E0' , c_int8_t )) == int ( z 'C0' , c_int8_t ) . and . & iand ( byte , int ( z '1F' , c_int8_t )) > int ( z '01' , c_int8_t )) then ! first byte: 110yyyyy and C2..DF if ( i + 1 > len ( str )) then r = . false .; return end if byte = cast_byte ( str ( i + 1 : i + 1 )) if ( iand ( byte , int ( z 'C0' , c_int8_t )) /= int ( z '80' , c_int8_t )) then ! secpnd byte: 10xxxxxx and 80..BF r = . false .; return end if i = i + 2 else if ( iand ( byte , int ( z 'F0' , c_int8_t )) == int ( z 'E0' , c_int8_t )) then ! first byte: 1110zzzz and E0..EF if ( i + 2 > len ( str )) then r = . false .; return end if if ( iand ( cast_byte ( str ( i + 1 : i + 1 )), int ( z 'C0' , c_int8_t )) /= int ( z '80' , c_int8_t ) . or . & iand ( cast_byte ( str ( i + 2 : i + 2 )), int ( z 'C0' , c_int8_t )) /= int ( z '80' , c_int8_t )) then ! second and third bytes: 10xxxxxx r = . false .; return end if if ( byte == int ( z 'E0' , c_int8_t )) then if ( iand ( cast_byte ( str ( i + 1 : i + 1 )), int ( z '3F' , c_int8_t )) < int ( z '20' , c_int8_t )) then ! E0  A0..BF  80..BF r = . false .; return end if end if if ( byte == int ( z 'ED' , c_int8_t )) then if ( iand ( cast_byte ( str ( i + 1 : i + 1 )), int ( z '3F' , c_int8_t )) > int ( z '1F' , c_int8_t )) then ! ED  80..9F  80..BF r = . false .; return end if end if i = i + 3 else if ( iand ( byte , int ( z 'F8' , c_int8_t )) == int ( z 'F0' , c_int8_t ) . and . & iand ( byte , int ( z '07' , c_int8_t )) < int ( z '05' , c_int8_t )) then ! first byte: 11110uuu and F0..F4 if ( i + 3 > len ( str )) then r = . false .; return end if if ( iand ( cast_byte ( str ( i + 1 : i + 1 )), int ( z 'C0' , c_int8_t )) /= int ( z '80' , c_int8_t ) . or . & iand ( cast_byte ( str ( i + 2 : i + 2 )), int ( z 'C0' , c_int8_t )) /= int ( z '80' , c_int8_t ) . or . & iand ( cast_byte ( str ( i + 3 : i + 3 )), int ( z 'C0' , c_int8_t )) /= int ( z '80' , c_int8_t )) then ! second, third, and last bytes: 10xxxxxx r = . false .; return end if if ( byte == int ( z 'F0' , c_int8_t )) then if ( iand ( cast_byte ( str ( i + 1 : i + 1 )), int ( z '3F' , c_int8_t )) < int ( z '10' , c_int8_t )) then ! F0  90..BF  80..BF  80..BF r = . false .; return end if end if if ( byte == int ( z 'F4' , c_int8_t )) then if ( iand ( cast_byte ( str ( i + 1 : i + 1 )), int ( z '3F' , c_int8_t )) > int ( z '0F' , c_int8_t )) then ! F4  80..8F  80..BF  80..BF r = . false .; return end if end if i = i + 4 else r = . false .; return end if end do r = . true . end function utf8_is_valid_char pure function utf8_is_valid_string ( str ) result ( r ) type ( utf8_string ), intent ( in ) :: str logical :: r r = utf8_is_valid_char ( str % str ) end function utf8_is_valid_string !> private helper functions !> cast char to byte (8-bits integer in Fortran) !> display: private pure function cast_byte ( char ) result ( byte ) character ( kind = c_char , len = 1 ), intent ( in ) :: char integer ( kind = c_int8_t ) :: byte byte = transfer ( char , byte ) end function cast_byte !> get the number of bytes of a code point based on its first byte !> display: private pure function codepoint_num_bytes ( byte ) result ( n ) integer ( kind = c_int8_t ), intent ( in ) :: byte integer :: n n = NUM_BYTES_UTF8 ( iand ( int ( byte , 4 ), int ( z '000000FF' , 4 ))) if ( n == 0 ) n = 1 end function codepoint_num_bytes end module utf8_detail","tags":"","loc":"sourcefile/utf8-f_detail.f90.html"}]}